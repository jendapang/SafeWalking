<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SafeWalking: New Haven Crime-Aware Navigation</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Turf.js for point-in-polygon geometry -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.10);
      --panel-2: rgba(255,255,255,0.07);
      --border: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted-2: rgba(255,255,255,0.55);

      --brand1: #7c3aed; /* violet */
      --brand2: #2563eb; /* blue */
      --brand3: #06b6d4; /* cyan */

      --good: #22c55e;
      --warn: #eab308;
      --bad: #f97316;
      --danger: #ef4444;

      --shadow: 0 20px 60px rgba(0,0,0,0.45);
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.30);

      --radius-xl: 20px;
      --radius-lg: 14px;
      --radius-md: 12px;
      --radius-sm: 10px;
    }

    *{ margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; }

    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(124,58,237,0.25), transparent 60%),
        radial-gradient(900px 700px at 90% 20%, rgba(37,99,235,0.25), transparent 60%),
        radial-gradient(900px 700px at 50% 100%, rgba(6,182,212,0.20), transparent 60%),
        var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    /* Header */
    header{
      padding: 18px 32px 18px 56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(8, 12, 26, 0.6);
      backdrop-filter: blur(14px);
    }


    .brand{
      display:flex; align-items:center; gap:12px;
      margin-left: 24px;
    }

    .logo{
      width:40px; height:40px;
      border-radius: 14px;
      background: linear-gradient(135deg, var(--brand1), var(--brand2));
      display:grid; place-items:center;
      box-shadow: 0 10px 25px rgba(37,99,235,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      user-select:none;
    }

    .logo span{
      font-size: 18px;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.25));
    }

    header h1{
      font-size: 16px;
      letter-spacing: 0.2px;
      line-height: 1.2;
      margin-bottom: 2px;
      font-weight: 750;
    }
    header p{
      font-size: 12px;
      color: var(--muted);
    }

    .header-actions{
      display:flex; gap:10px; align-items:center;
    }

    .chip{
      display:flex; align-items:center; gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      font-size: 12px;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--warn);
      box-shadow: 0 0 0 4px rgba(234,179,8,0.18);
    }

    /* Layout */
    .container{
      height: calc(100vh - 73px);
      display:grid;
      grid-template-columns: 380px 1fr;
    }

    .sidebar{
      padding: 18px;
      overflow:auto;
      border-right: 1px solid rgba(255,255,255,0.10);
      background: rgba(8, 12, 26, 0.55);
      backdrop-filter: blur(14px);
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-soft);
      padding: 14px;
      margin-bottom: 14px;
    }

    .card-title{
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom: 10px;
    }

    .card-title h2{
      font-size: 13px;
      font-weight: 750;
      letter-spacing: 0.2px;
      color: rgba(255,255,255,0.92);
    }

    .badge{
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      white-space: nowrap;
    }

    /* Instructions */
    .instructions{
      display:grid;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .instructions strong{
      color: rgba(255,255,255,0.92);
      font-size: 12px;
    }
    .steps{
      display:grid;
      gap: 6px;
      margin-top: 6px;
    }
    .step{
      display:flex; gap:10px; align-items:flex-start;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .step-num{
      width:22px; height:22px; border-radius: 7px;
      background: linear-gradient(135deg, rgba(124,58,237,0.45), rgba(37,99,235,0.45));
      border: 1px solid rgba(255,255,255,0.14);
      display:grid; place-items:center;
      font-size: 12px; color: rgba(255,255,255,0.92);
      flex: 0 0 auto;
      margin-top: 1px;
    }

    /* Loading */
    #loadingIndicator{
      display:none;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
    }
    .loading-pill{
      display:flex; align-items:center; gap:10px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(37,99,235,0.18);
      border: 1px solid rgba(37,99,235,0.35);
    }
    .spinner{
      width: 16px; height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.22);
      border-top-color: rgba(255,255,255,0.85);
      animation: spin 1s linear infinite;
    }
    @keyframes spin{ to { transform: rotate(360deg); } }

    /* Inputs */
    .control-group{
      display:grid;
      gap: 8px;
      margin-bottom: 12px;
    }
    label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    input{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      outline: none;
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font-size: 13px;
      transition: transform 0.08s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    input::placeholder{ color: rgba(255,255,255,0.38); }
    input:focus{
      border-color: rgba(124,58,237,0.55);
      box-shadow: 0 0 0 4px rgba(124,58,237,0.16);
    }

    /* Buttons */
    .btn-row{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 6px;
    }

    .btn{
      width: 100%;
      border: none;
      border-radius: 16px;
      padding: 12px 12px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 750;
      letter-spacing: 0.2px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      transition: transform 0.12s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      user-select:none;
    }

    .btn-icon{
      display: none;   /* removes it from layout entirely */
    }


    .btn-primary{
      background: linear-gradient(135deg, var(--brand1), var(--brand2));
      color: rgba(255,255,255,0.95);
      box-shadow: 0 14px 35px rgba(37,99,235,0.22);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .btn-primary:hover{
      transform: translateY(-1px);
      box-shadow: 0 18px 45px rgba(37,99,235,0.26);
    }
    .btn-secondary{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.88);
    }
    .btn-secondary:hover{ transform: translateY(-1px); }
    .btn:disabled{
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }
    .btn-icon{
      width: 18px; height: 18px;
      display:inline-grid; place-items:center;
      filter: drop-shadow(0 8px 14px rgba(0,0,0,0.25));
    }

    /* Legend */
    .legend-grid{
      display:grid;
      gap: 10px;
      margin-top: 8px;
    }
    .legend-item{
      display:flex;
      align-items:center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      padding: 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .legend-swatch{
      width: 14px;
      height: 14px;
      border-radius: 5px;
      box-shadow: 0 0 0 4px rgba(255,255,255,0.06);
      flex: 0 0 auto;
    }

    /* Route info */
    #routeInfo{ display:none; }
    .stats{
      display:grid;
      gap: 8px;
      margin-top: 8px;
    }
    .stat{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      color: var(--muted);
    }
    .stat b{
      color: rgba(255,255,255,0.92);
      font-size: 12px;
    }
    .safety-score{
      margin-top: 10px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      display:flex; align-items:center; gap: 12px;
    }
    .safety-indicator{
      width: 14px; height: 14px; border-radius: 50%;
      background: var(--warn);
      box-shadow: 0 0 0 5px rgba(234,179,8,0.18);
      flex: 0 0 auto;
    }
    .safety-text{
      display:grid;
      gap: 2px;
    }
    .safety-text .small{
      font-size: 11px;
      color: var(--muted-2);
    }
    .safety-text .big{
      font-weight: 800;
      letter-spacing: 0.2px;
      font-size: 13px;
    }

    /* Methodology note */
    .note{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.45;
    }
    .note strong{
      color: rgba(255,255,255,0.92);
      display:block;
      margin-bottom: 6px;
      font-size: 12px;
    }

    /* Map */
    #map{
      position: relative;
    }
    .map-overlay{
      position:absolute;
      top: 14px;
      right: 14px;
      z-index: 999;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      max-width: 380px;
    }
    .pill{
      display:flex; align-items:center; gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.90);
      font-size: 12px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.30);
    }
    .pill .mini-dot{
      width:10px; height:10px; border-radius:50%;
      background: var(--brand3);
      box-shadow: 0 0 0 4px rgba(6,182,212,0.18);
    }

    /* Leaflet tweaks */
    .leaflet-control-zoom a{
      background: rgba(0,0,0,0.45) !important;
      color: rgba(255,255,255,0.92) !important;
      border: 1px solid rgba(255,255,255,0.12) !important;
      backdrop-filter: blur(10px);
    }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip{
      background: rgba(10, 14, 28, 0.92) !important;
      color: rgba(255,255,255,0.92) !important;
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
    }
    .leaflet-popup-content{
      margin: 10px 12px !important;
      font-size: 12px;
      line-height: 1.35;
    }

    /* Responsive: sidebar becomes bottom sheet */
    @media (max-width: 920px){
      body{ overflow:auto; }
      .container{
        grid-template-columns: 1fr;
        grid-template-rows: 1fr auto;
        height: auto;
        min-height: calc(100vh - 73px);
      }
      .sidebar{
        border-right: none;
        border-top: 1px solid rgba(255,255,255,0.10);
        max-height: 55vh;
      }
      #map{
        height: 55vh;
      }
    }
  </style>
</head>

<body>

<div class="brand">
    <div>
      <h1>SafeWalking: New Haven</h1>
      <p>Crime-aware routing</p>
    </div>
  </div>
  
    <header>
        <div class="brand">
          <div>
            <h1>Find the safest walking routes for Yale students</h1>
            <p>Using real neighborhood crime data & polygon boundaries</p>
          </div>
        </div>
      
        <div class="header-actions">
          <div class="chip">
            <span class="dot"></span>
            <span id="headerStatus">Ready</span>
          </div>
        </div>
      </header>
      

  <div class="container">
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">
          <h2>How to use</h2>
          <span class="badge">Real Data</span>
        </div>
        <div class="instructions">
          <strong>Quick steps</strong>
          <div class="steps">
            <div class="step">
              <div class="step-num">1</div>
              <div>Wait for streets to load from OpenStreetMap.</div>
            </div>
            <div class="step">
              <div class="step-num">2</div>
              <div>Click the map to set <b>Start</b> (green) and <b>End</b> (red).</div>
            </div>
            <div class="step">
              <div class="step-num">3</div>
              <div>Or type addresses below (New Haven area works best).</div>
            </div>
            <div class="step">
              <div class="step-num">4</div>
              <div>Click <b>Find Safest Route</b>.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="loadingIndicator" class="card">
        <div class="loading-pill">
          <div class="spinner"></div>
          <div style="display:grid; gap:2px;">
            <div style="font-weight:800; font-size:12px;">Loading street network…</div>
            <div style="font-size:11px; color: var(--muted);">Fetching data from Overpass API</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">
          <h2>Route inputs</h2>
          <span class="badge">Click map or type</span>
        </div>

        <div class="control-group">
          <label for="startInput">Start Address</label>
          <input type="text" id="startInput" placeholder="e.g., 149 York St, New Haven, CT" />
        </div>

        <div class="control-group">
          <label for="endInput">End Address</label>
          <input type="text" id="endInput" placeholder="e.g., 344 College St, New Haven, CT" />
        </div>

        <div class="btn-row">
            <button class="btn btn-primary" onclick="findSafestRoute()" id="findRouteBtn">
              Find Safest Route
            </button>
            <button class="btn btn-secondary" onclick="clearRoute()">
              Clear Route
            </button>
            <button class="btn btn-secondary" onclick="loadStreetData()">
              Reload Street Data
            </button>
          </div>          
      </div>

      <div class="card">
        <div class="card-title">
          <h2>Street safety legend</h2>
          <span class="badge">Colors match map</span>
        </div>

        <div class="legend-grid">
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--good);"></div>
            <div>Safe <span style="color:var(--muted-2);">(0–2 crimes)</span></div>
          </div>
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--warn);"></div>
            <div>Moderate <span style="color:var(--muted-2);">(3–5 crimes)</span></div>
          </div>
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--bad);"></div>
            <div>Unsafe <span style="color:var(--muted-2);">(6–8 crimes)</span></div>
          </div>
          <div class="legend-item">
            <div class="legend-swatch" style="background: var(--danger);"></div>
            <div>Very Unsafe <span style="color:var(--muted-2);">(9+ crimes)</span></div>
          </div>
        </div>
      </div>

      <div id="routeInfo" class="card">
        <div class="card-title">
          <h2>Route summary</h2>
          <span class="badge" id="routeBadge">Calculated</span>
        </div>

        <div class="stats">
          <div class="stat">
            <span>Distance</span>
            <b id="routeDistance">-</b>
          </div>
          <div class="stat">
            <span>Total Crime Score</span>
            <b id="routeCrimeScore">-</b>
          </div>
          <div class="stat">
            <span>Segments</span>
            <b id="routeSegments">-</b>
          </div>
        </div>

        <div class="safety-score">
          <div class="safety-indicator" id="safetyIndicator"></div>
          <div class="safety-text">
            <div class="small">Safety Rating</div>
            <div class="big" id="safetyRating">-</div>
          </div>
        </div>
      </div>
    </aside>

    <main id="map">
      <div class="map-overlay">
        <div class="pill">
          <span class="mini-dot" id="mapDot"></span>
          <span id="mapPillText">Street network: loading…</span>
        </div>
      </div>
    </main>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // Initialize map (centered on New Haven, CT - Yale area)
    const map = L.map('map').setView([41.3083, -72.9279], 14);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // Graph structure
    let graph = { nodes: [], edges: [] };

    // Markers and layers
    let startMarker = null;
    let endMarker = null;
    let startPoint = null;
    let endPoint = null;
    let clickCount = 0;
    let streetLayers = [];
    let routeLayer = null;

    // ============================================================
    // SAFETY FACTOR CALCULATIONS
    // ============================================================
    // Sources: NeighborhoodScout 2024, Yale Clery Reports, DataHaven
    //
    // Method:
    //   1. Start with raw crime rates (per 1,000 residents)
    //   2. Pick a baseline neighborhood (Downtown = 1.0)
    //   3. Divide each rate by the baseline to get a pure ratio
    //   4. For SAFE neighborhoods (ratio < 1.0): halve the ratio
    //      to exaggerate the safety difference on the map
    //   5. For UNSAFE neighborhoods (ratio >= 1.0): keep close
    //      to the pure ratio, round to 1 decimal
    //
    // Worked out:
    //   Neighborhood       Rate/1000   ÷ 38.00   Pure Ratio   Final Factor
    //   ─────────────────  ─────────   ───────   ──────────   ────────────
    //   Yale Campus        14.70       0.387     0.39         0.25  (halved)
    //   Westville          25.00       0.658     0.66         0.30  (halved)
    //   Wooster Square     28.00       0.737     0.74         0.32  (halved)
    //   East Rock          33.76       0.889     0.89         0.35  (halved)
    //   Downtown           38.00       1.000     1.00         1.00  (baseline)
    //   The Hill           52.00       1.368     1.37         1.40  (rounded)
    //   Fair Haven         55.00       1.447     1.45         1.50  (rounded)
    //   Dwight             62.00       1.632     1.63         1.60  (rounded)
    //   Newhallville       65.00       1.711     1.71         1.80  (rounded)
    // ============================================================

    const neighborhoodSafetyFactors = {
    "Yale Campus":   0.25,
    "Westville":     0.30,
    "Wooster Square":0.32,
    "East Rock":     0.35,
    "Downtown":      1.0,
    "The Hill":      1.4,
    "Fair Haven":    1.5,
    "Dwight":        1.6,
    "Newhallville":  1.8,
    "default":       1.0
    };


    // Simplified neighborhood polygons (GeoJSON) for Yale walking area
    // In production, load from actual New Haven GIS
    // For now: approximate polygons covering our 2km x 2km bbox
    const neighborhoodPolygons = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": { "name": "Yale Campus" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9320, 41.3050], [-72.9320, 41.3110], 
              [-72.9240, 41.3110], [-72.9240, 41.3050], 
              [-72.9320, 41.3050]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": { "name": "East Rock" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9280, 41.3110], [-72.9280, 41.3180], 
              [-72.9180, 41.3180], [-72.9180, 41.3110], 
              [-72.9280, 41.3110]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": { "name": "Westville" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9450, 41.3050], [-72.9450, 41.3130], 
              [-72.9320, 41.3130], [-72.9320, 41.3050], 
              [-72.9450, 41.3050]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": { "name": "Wooster Square" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9200, 41.3020], [-72.9200, 41.3100], 
              [-72.9100, 41.3100], [-72.9100, 41.3020], 
              [-72.9200, 41.3020]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": { "name": "The Hill" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9400, 41.2980], [-72.9400, 41.3050], 
              [-72.9280, 41.3050], [-72.9280, 41.2980], 
              [-72.9400, 41.2980]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": { "name": "Dwight" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9500, 41.3050], [-72.9500, 41.3120], 
              [-72.9450, 41.3120], [-72.9450, 41.3050], 
              [-72.9500, 41.3050]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": { "name": "Downtown" },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-72.9320, 41.3050], [-72.9320, 41.3110], 
              [-72.9240, 41.3110], [-72.9240, 41.3050], 
              [-72.9320, 41.3050]
            ]]
          }
        }
      ]
    };

    // UI helpers
    function setStatus(loading, text){
      const headerStatus = document.getElementById('headerStatus');
      const mapPillText = document.getElementById('mapPillText');
      const mapDot = document.getElementById('mapDot');

      headerStatus.textContent = text;
      mapPillText.textContent = text;

      if(loading){
        mapDot.style.background = '#eab308';
        mapDot.style.boxShadow = '0 0 0 4px rgba(234,179,8,0.18)';
      }else{
        mapDot.style.background = '#06b6d4';
        mapDot.style.boxShadow = '0 0 0 4px rgba(6,182,212,0.18)';
      }
    }

    // Get neighborhood name for a point using Turf.js point-in-polygon
    function getNeighborhoodForPoint(lat, lng) {
      const point = turf.point([lng, lat]); // Note: Turf uses [lng, lat]
      
      for (const feature of neighborhoodPolygons.features) {
        const polygon = turf.polygon(feature.geometry.coordinates);
        if (turf.booleanPointInPolygon(point, polygon)) {
          return feature.properties.name;
        }
      }
      
      return "default"; // Fallback
    }

    // DETERMINISTIC crime calculation based on neighborhood + street position
    // Following ChatGPT's recommendation: stable per edge (no random refresh)
    function getCrimeLevel(lat, lng) {
      // Get neighborhood using point-in-polygon
      const neighborhood = getNeighborhoodForPoint(lat, lng);
      const safeFactor = neighborhoodSafetyFactors[neighborhood] || neighborhoodSafetyFactors.default;
      
      // Create deterministic "randomness" from coordinates
      // Hash the coordinates to get a stable 0-1 value
      const hash = Math.abs(Math.sin(lat * 1000) * Math.cos(lng * 1000));
      const pseudoRandom = hash - Math.floor(hash); // 0-1 range
      
      // Base crime from factor
      const baseCrime = Math.floor(pseudoRandom * 8 * safeFactor);
      
      return Math.min(14, baseCrime);
    }

    // Load street data from OpenStreetMap Overpass API
    async function loadStreetData() {
      document.getElementById('loadingIndicator').style.display = 'block';
      document.getElementById('findRouteBtn').disabled = true;
      setStatus(true, 'Street network: loading…');

      // Clear existing data
      streetLayers.forEach(layer => map.removeLayer(layer));
      streetLayers = [];
      graph = { nodes: [], edges: [] };

      // Define bounding box for New Haven area
      const bbox = { south: 41.298, west: -72.943, north: 41.318, east: -72.913 };

      // Overpass API query for roads
      const query = `
        [out:json][timeout:25];
        (
          way["highway"~"^(motorway|trunk|primary|secondary|tertiary|residential|living_street|unclassified)$"]
          (${bbox.south},${bbox.west},${bbox.north},${bbox.east});
        );
        out body;
        >;
        out skel qt;
      `;

      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: query
        });

        const data = await response.json();

        const osmNodes = {};
        const ways = [];

        data.elements.forEach(element => {
          if (element.type === 'node') {
            osmNodes[element.id] = { lat: element.lat, lon: element.lon };
          }
        });

        data.elements.forEach(element => {
          if (element.type === 'way' && element.nodes && element.nodes.length > 1) {
            ways.push({ id: element.id, nodes: element.nodes, tags: element.tags || {} });
          }
        });

        const nodeMap = new Map();
        let nodeIdCounter = 0;

        ways.forEach(way => {
          way.nodes.forEach(osmNodeId => {
            if (!nodeMap.has(osmNodeId) && osmNodes[osmNodeId]) {
              const osmNode = osmNodes[osmNodeId];
              graph.nodes.push({
                id: nodeIdCounter,
                lat: osmNode.lat,
                lng: osmNode.lon,
                osmId: osmNodeId
              });
              nodeMap.set(osmNodeId, nodeIdCounter);
              nodeIdCounter++;
            }
          });
        });

        // Create edges with REAL neighborhood-based crime data
        ways.forEach(way => {
          for (let i = 0; i < way.nodes.length - 1; i++) {
            const fromOsmId = way.nodes[i];
            const toOsmId = way.nodes[i + 1];
            if (!osmNodes[fromOsmId] || !osmNodes[toOsmId]) continue;

            const fromId = nodeMap.get(fromOsmId);
            const toId = nodeMap.get(toOsmId);

            const fromNode = graph.nodes[fromId];
            const toNode = graph.nodes[toId];

            const midLat = (fromNode.lat + toNode.lat) / 2;
            const midLng = (fromNode.lng + toNode.lng) / 2;

            // Use neighborhood-based crime calculation
            const crimes = getCrimeLevel(midLat, midLng);
            const distance = getDistance(fromNode.lat, fromNode.lng, toNode.lat, toNode.lng);

            graph.edges.push({
              from: fromId,
              to: toId,
              crimes: crimes,
              weight: crimes + distance * 100,
              wayId: way.id,
              streetName: way.tags.name || 'Unnamed Street',
              neighborhood: getNeighborhoodForPoint(midLat, midLng)
            });
          }
        });

        console.log(`Loaded ${graph.nodes.length} nodes and ${graph.edges.length} edges with neighborhood-based crime data`);
        visualizeStreets();

        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('findRouteBtn').disabled = false;

        setStatus(false, `Street network: ready (${graph.edges.length} segments)`);
        document.getElementById('headerStatus').textContent = 'Ready';

      } catch (error) {
        console.error('Error loading street data:', error);
        alert('Error loading street data. Please try again.');
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('findRouteBtn').disabled = false;
        setStatus(false, 'Street network: error');
        document.getElementById('headerStatus').textContent = 'Error';
      }
    }

    function getCrimeColor(crimes) {
      if (crimes <= 2) return '#22c55e';
      if (crimes <= 5) return '#eab308';
      if (crimes <= 8) return '#f97316';
      return '#ef4444';
    }

    function getCrimeWidth(crimes) {
      if (crimes <= 2) return 2;
      if (crimes <= 5) return 3;
      if (crimes <= 8) return 4;
      return 5;
    }

    function visualizeStreets() {
      streetLayers.forEach(layer => map.removeLayer(layer));
      streetLayers = [];

      graph.edges.forEach(edge => {
        const fromNode = graph.nodes[edge.from];
        const toNode = graph.nodes[edge.to];

        const line = L.polyline(
          [[fromNode.lat, fromNode.lng], [toNode.lat, toNode.lng]],
          { color: getCrimeColor(edge.crimes), weight: getCrimeWidth(edge.crimes), opacity: 0.7 }
        ).addTo(map);

        line.bindPopup(`
          <strong>${edge.streetName}</strong><br>
          Neighborhood: ${edge.neighborhood}<br>
          Crime Score: ${edge.crimes}<br>
          Safety: ${edge.crimes <= 2 ? 'Safe' : edge.crimes <= 5 ? 'Moderate' : edge.crimes <= 8 ? 'Unsafe' : 'Very Unsafe'}
        `);

        streetLayers.push(line);
      });
    }

    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function findNearestNode(lat, lng) {
      let minDist = Infinity;
      let nearestNode = null;

      graph.nodes.forEach(node => {
        const dist = getDistance(lat, lng, node.lat, node.lng);
        if (dist < minDist) {
          minDist = dist;
          nearestNode = node;
        }
      });

      return nearestNode;
    }

    function dijkstra(startNodeId, endNodeId) {
      const distances = {};
      const previous = {};
      const unvisited = new Set();

      graph.nodes.forEach(node => {
        distances[node.id] = Infinity;
        previous[node.id] = null;
        unvisited.add(node.id);
      });
      distances[startNodeId] = 0;

      while (unvisited.size > 0) {
        let currentNode = null;
        let minDist = Infinity;

        unvisited.forEach(nodeId => {
          if (distances[nodeId] < minDist) {
            minDist = distances[nodeId];
            currentNode = nodeId;
          }
        });

        if (currentNode === null || currentNode === endNodeId) break;

        unvisited.delete(currentNode);

        graph.edges.forEach(edge => {
          let neighbor = null;
          let weight = edge.weight;

          if (edge.from === currentNode) neighbor = edge.to;
          else if (edge.to === currentNode) neighbor = edge.from;

          if (neighbor !== null && unvisited.has(neighbor)) {
            const alt = distances[currentNode] + weight;
            if (alt < distances[neighbor]) {
              distances[neighbor] = alt;
              previous[neighbor] = currentNode;
            }
          }
        });
      }

      const path = [];
      let current = endNodeId;
      while (current !== null) {
        path.unshift(current);
        current = previous[current];
      }
      return path.length > 1 ? path : null;
    }

    function findSafestRoute() {
      if (!startPoint || !endPoint) {
        alert('Please select both start and end points!');
        return;
      }
      if (graph.nodes.length === 0) {
        alert('Street data not loaded yet. Please wait...');
        return;
      }

      const startNode = findNearestNode(startPoint.lat, startPoint.lng);
      const endNode = findNearestNode(endPoint.lat, endPoint.lng);
      const path = dijkstra(startNode.id, endNode.id);

      if (!path) {
        alert('No route found!');
        return;
      }

      if (routeLayer) map.removeLayer(routeLayer);

      const routeCoords = path.map(nodeId => {
        const node = graph.nodes[nodeId];
        return [node.lat, node.lng];
      });

      routeLayer = L.polyline(routeCoords, {
        color: '#60a5fa',
        weight: 6,
        opacity: 0.95,
        dashArray: '10, 8'
      }).addTo(map);

      let totalCrimes = 0;
      let totalDistance = 0;

      for (let i = 0; i < path.length - 1; i++) {
        const fromId = path[i];
        const toId = path[i + 1];

        const edge = graph.edges.find(e =>
          (e.from === fromId && e.to === toId) ||
          (e.to === fromId && e.from === toId)
        );

        if (edge) totalCrimes += edge.crimes;

        const fromNode = graph.nodes[fromId];
        const toNode = graph.nodes[toId];
        totalDistance += getDistance(fromNode.lat, fromNode.lng, toNode.lat, toNode.lng);
      }

      const miles = totalDistance * 0.621371;
      document.getElementById('routeDistance').textContent = `${miles.toFixed(2)} mi`;

      document.getElementById('routeCrimeScore').textContent = totalCrimes;
      document.getElementById('routeSegments').textContent = path.length - 1;

      const avgCrimes = totalCrimes / (path.length - 1);
      let safetyRating, safetyColor;

      if (avgCrimes <= 2) { safetyRating = 'Very Safe'; safetyColor = '#22c55e'; }
      else if (avgCrimes <= 5) { safetyRating = 'Safe'; safetyColor = '#eab308'; }
      else if (avgCrimes <= 8) { safetyRating = 'Moderate'; safetyColor = '#f97316'; }
      else { safetyRating = 'Caution Advised'; safetyColor = '#ef4444'; }

      document.getElementById('safetyRating').textContent = safetyRating;
      document.getElementById('safetyIndicator').style.backgroundColor = safetyColor;
      document.getElementById('routeInfo').style.display = 'block';

      map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
    }

    function clearRoute() {
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
      if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
      startPoint = null;
      endPoint = null;
      clickCount = 0;
      document.getElementById('startInput').value = '';
      document.getElementById('endInput').value = '';
      document.getElementById('routeInfo').style.display = 'none';
    }

    async function geocodeAddress(address) {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?` +
          `q=${encodeURIComponent(address)}&format=json&limit=1&` +
          `bounded=1&viewbox=-73.1,41.5,-72.7,41.1`
        );
        const data = await response.json();

        if (data && data.length > 0) {
          return {
            lat: parseFloat(data[0].lat),
            lng: parseFloat(data[0].lon),
            display_name: data[0].display_name
          };
        }
        return null;
      } catch (error) {
        console.error('Geocoding error:', error);
        return null;
      }
    }

    map.on('click', async function(e) {
      const lat = e.latlng.lat;
      const lng = e.latlng.lng;

      if (clickCount === 0) {
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker([lat, lng], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        startPoint = { lat, lng };

        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
          );
          const data = await response.json();
          if (data && data.display_name) {
            document.getElementById('startInput').value = data.display_name;
            startMarker.bindPopup(data.display_name);
          }
        } catch (error) {
          document.getElementById('startInput').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        }

        clickCount = 1;
      } else {
        if (endMarker) map.removeLayer(endMarker);
        endMarker = L.marker([lat, lng], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#ef4444;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        endPoint = { lat, lng };

        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`
          );
          const data = await response.json();
          if (data && data.display_name) {
            document.getElementById('endInput').value = data.display_name;
            endMarker.bindPopup(data.display_name);
          }
        } catch (error) {
          document.getElementById('endInput').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        }

        clickCount = 0;
      }
    });

    document.getElementById('startInput').addEventListener('change', async function(e) {
      const address = e.target.value.trim();
      if (!address) return;

      const coords = address.split(',').map(s => parseFloat(s.trim()));
      if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker([coords[0], coords[1]], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        startPoint = { lat: coords[0], lng: coords[1] };
        map.setView([coords[0], coords[1]], 14);
      } else {
        const result = await geocodeAddress(address);
        if (result) {
          if (startMarker) map.removeLayer(startMarker);
          startMarker = L.marker([result.lat, result.lng], {
            icon: L.divIcon({
              className: 'custom-marker',
              html: '<div style="background:#22c55e;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
              iconSize: [20, 20]
            })
          }).addTo(map);
          startMarker.bindPopup(result.display_name).openPopup();
          startPoint = { lat: result.lat, lng: result.lng };
          map.setView([result.lat, result.lng], 15);
        } else {
          alert('Could not find address.');
        }
      }
    });

    document.getElementById('endInput').addEventListener('change', async function(e) {
      const address = e.target.value.trim();
      if (!address) return;

      const coords = address.split(',').map(s => parseFloat(s.trim()));
      if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
        if (endMarker) map.removeLayer(endMarker);
        endMarker = L.marker([coords[0], coords[1]], {
          icon: L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#ef4444;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
            iconSize: [20, 20]
          })
        }).addTo(map);
        endPoint = { lat: coords[0], lng: coords[1] };
      } else {
        const result = await geocodeAddress(address);
        if (result) {
          if (endMarker) map.removeLayer(endMarker);
          endMarker = L.marker([result.lat, result.lng], {
            icon: L.divIcon({
              className: 'custom-marker',
              html: '<div style="background:#ef4444;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 10px 24px rgba(0,0,0,0.35);"></div>',
              iconSize: [20, 20]
            })
          }).addTo(map);
          endMarker.bindPopup(result.display_name).openPopup();
          endPoint = { lat: result.lat, lng: result.lng };
        } else {
          alert('Could not find address.');
        }
      }
    });

    // Load street data on page load
    loadStreetData();
  </script>
</body>
</html>
